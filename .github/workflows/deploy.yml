name: Deploy eAssist API

run-name: Deploy eAssist API to Production (${{ github.sha }})

on:
  push:
    branches: [ "releases" ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy and Restart API
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/releases' }}
    env:
      DEPLOY_PATH: /opt/eassist-api
      DEPLOY_HOST: ${{ secrets.DEPLOY_HOST || '194.163.173.144' }}
      DEPLOY_USER: ${{ secrets.DEPLOY_USER || 'gitdeploy' }}
      DEPLOY_PORT: ${{ secrets.DEPLOY_PORT || '22' }}
      GIT_SHA: ${{ github.sha }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate prerequisites
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.EASSIST_API_SRV }}" ]; then
            echo '::error::Missing required secret: EASSIST_API_SRV' >&2; exit 1;
          fi
          echo 'Prerequisites OK.'

      - name: Prepare SSH key & known_hosts
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.EASSIST_API_SRV }}" > ~/.ssh/id_deploy
          chmod 600 ~/.ssh/id_deploy
          ssh-keygen -lf ~/.ssh/id_deploy | sed "s/.*/Loaded private key fingerprint: &/"
          ssh-keyscan -p "$DEPLOY_PORT" -H "$DEPLOY_HOST" > ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Install rsync
        run: sudo apt-get update -y && sudo apt-get install -y rsync

      - name: Sync project files to server
        run: |
          set -euo pipefail
          RSYNC_RSH="ssh -i ~/.ssh/id_deploy -p ${DEPLOY_PORT} -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes"
          rsync -az --delete \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.env' \
            -e "$RSYNC_RSH" ./ "${DEPLOY_USER}@${DEPLOY_HOST}:${DEPLOY_PATH}/"

      - name: Remote Deployment Script
        id: remote_deploy
        continue-on-error: true
        run: |
          set -euo pipefail
          ssh -i ~/.ssh/id_deploy -p "$DEPLOY_PORT" -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes "${DEPLOY_USER}@${DEPLOY_HOST}" \
            "DEPLOY_PATH='${DEPLOY_PATH}' GIT_SHA='${GIT_SHA}' bash -s" <<'EOF'
          set -euo pipefail
          STATUS_FILE="remote_deploy_status.txt"
          fail() { echo "$1" > "$STATUS_FILE"; echo "::error::$1"; exit 1; }
          log() { echo "[Remote] $1"; }

          port_in_use() {
            # Returns 0 if something is LISTENING on 8080
            if command -v sudo >/dev/null 2>&1; then
              sudo lsof -nP -iTCP:8080 -sTCP:LISTEN >/dev/null 2>&1 && return 0 || return 1
            else
              lsof -nP -iTCP:8080 -sTCP:LISTEN >/dev/null 2>&1 && return 0 || return 1
            fi
          }

          list_port_process() {
            if command -v sudo >/dev/null 2>&1; then
              sudo lsof -nP -iTCP:8080 -sTCP:LISTEN || true
              sudo ss -ltnp 2>/dev/null | grep ':8080' || true
            else
              lsof -nP -iTCP:8080 -sTCP:LISTEN || true
              ss -ltnp 2>/dev/null | grep ':8080' || true
            fi
          }

          kill_port_processes() {
            log "Attempting to free port 8080"
            list_port_process
            if command -v sudo >/dev/null 2>&1; then
              sudo fuser -k 8080/tcp 2>/dev/null || true
              sudo lsof -nP -iTCP:8080 -sTCP:LISTEN -t 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true
            else
              fuser -k 8080/tcp 2>/dev/null || true
              lsof -nP -iTCP:8080 -sTCP:LISTEN -t 2>/dev/null | xargs -r kill -9 2>/dev/null || true
            fi
            sleep 2
            if port_in_use; then
              log "Port still in use after kill; retrying with process table dump"
              ps -ef | grep -E 'node|npm' | grep -v grep || true
              list_port_process
            else
              log "Port 8080 appears free"
            fi
          }

          log "Starting deployment job"
          cd "$DEPLOY_PATH" || fail "Cannot cd to $DEPLOY_PATH"
          log "Current submodule commit: $(git rev-parse HEAD || echo 'unknown')"

          log "Checking for Node.js and npm"
          command -v node >/dev/null || fail "Node.js not found on PATH"
          command -v npm >/dev/null || fail "npm not found on PATH"
          log "Node: $(node -v), npm: $(npm -v)"

          if [ ! -f .env ]; then log "Warning: .env file not found. DB connection may fail."; fi

            # Print existing listener BEFORE touching anything
          if port_in_use; then
            log "Port 8080 currently occupied BEFORE deploy:"
            list_port_process
          else
            log "Port 8080 free BEFORE deploy"
          fi

          log "Installing/updating production dependencies"
          npm ci --only=production --prefer-offline --no-audit || npm install --only=production

          log "Running database migrations"
          npm run migrate:run || npm run migrate || log "Warning: Migration script failed or not found."

          log "Stopping service / processes"
          if command -v systemctl >/dev/null 2>&1 && systemctl list-units --type=service --all | grep -q "eassist-api" 2>/dev/null; then
            log "Stopping systemd service eassist-api"
            sudo -n systemctl stop eassist-api 2>/dev/null || true
            sudo -n systemctl kill eassist-api 2>/dev/null || true
            sudo -n systemctl reset-failed eassist-api 2>/dev/null || true
            sleep 2
          fi

          # Multiple aggressive cleanup passes
          for i in 1 2 3; do
            if port_in_use; then
              log "Cleanup pass $i: killing port listeners"
              kill_port_processes
            else
              break
            fi
          done

          # Final assertion
          if port_in_use; then
            list_port_process
            fail "Cannot free port 8080 after multiple attempts"
          fi
          log "Confirmed port 8080 free prior to start"

          START_METHOD="none"
          STARTED=0

          if command -v systemctl >/dev/null 2>&1 && systemctl list-units --type=service --all | grep -q "eassist-api" 2>/dev/null; then
            log "Starting via systemd"
            sudo -n systemctl start eassist-api 2>/dev/null || true
            sleep 3
            if port_in_use; then
              STARTED=1
              START_METHOD="systemd"
              log "Service listening on 8080 via systemd"
            else
              log "Systemd start attempted but port not in LISTEN state"
              sudo -n systemctl status eassist-api --no-pager || true
            fi
          fi

          # Only attempt pm2 / nohup if NO systemd unit or systemd failed
          if [ "$STARTED" -eq 0 ]; then
            if command -v pm2 >/dev/null 2>&1; then
              log "Attempting pm2 start"
              pm2 delete eassist-api 2>/dev/null || true
              pm2 start npm --name eassist-api -- start 2>/dev/null || true
              sleep 4
              if port_in_use; then
                STARTED=1
                START_METHOD="pm2"
                log "Service listening on 8080 via pm2"
              else
                log "pm2 start failed to bind port"
                pm2 logs eassist-api --lines 20 2>/dev/null || true
              fi
            fi
          fi

          if [ "$STARTED" -eq 0 ]; then
            log "Falling back to raw nohup"
            # Double-check port still free right before
            if port_in_use; then
              list_port_process
              fail "Race: port became used just before nohup start"
            fi
            sudo mkdir -p /var/log 2>/dev/null || true
            sudo touch /var/log/eassist-api.out 2>/dev/null || true
            sudo chown "$USER" /var/log/eassist-api.out 2>/dev/null || true
            NODE_ENV=production nohup npm start >/var/log/eassist-api.out 2>&1 &
            NEW_PID=$!
            log "Spawned PID $NEW_PID (nohup)"
            sleep 5
            if port_in_use; then
              STARTED=1
              START_METHOD="nohup"
              log "Service listening on 8080 via nohup (PID: $(sudo lsof -nP -iTCP:8080 -sTCP:LISTEN -t 2>/dev/null | tr '\n' ' '))"
            else
              log "Failed to bind after nohup start. Tail log:"
              tail -n 60 /var/log/eassist-api.out 2>/dev/null || true
              fail "Service failed to start (nohup)"
            fi
          fi

          if [ "$STARTED" -eq 0 ]; then
            fail "All start strategies failed"
          fi

          log "Startup method: $START_METHOD"
          log "Active listeners:"
          list_port_process

          echo "OK" > "$STATUS_FILE"
          log "Deployment script finished successfully"
          EOF

      - name: Check deployment status
        if: always()
        run: |
          if [ "${{ steps.remote_deploy.outcome }}" != "success" ]; then
            echo "::error::Deployment failed. Check the logs above for details.";
            exit 1;
          fi
          echo "Deployment completed successfully."
